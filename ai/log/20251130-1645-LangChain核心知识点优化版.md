# LangChain 核心知识点优化版

> **用途**：用于生成 Jupyter Notebook 教学文档
> 
> **原则**：最少最关键最有效的代码验证知识点

---

## 一、基础层：LLM + Prompt

### ChatModels（ChatTongyi）
**知识点说明**：ChatTongyi 是与通义千问对话的核心接口，统一调用大模型，通过参数控制输出风格。

**学习要求**：
- 掌握 ChatTongyi 基础调用
- 理解核心参数作用
- 能控制输出风格

**案例要求**：
- 使用 ChatTongyi 运行简单对话
- 设置 temperature = 0.7（推荐值）
- 设置 max_tokens = 500（实用值）
- 验证点：能成功获取 AI 回复并控制输出长度

### 核心参数（model / temperature / max_tokens）
**知识点说明**：这些参数用于控制 LLM 的行为，如模型选择、随机性、生成长度等。

**学习要求**：
- 理解各参数的作用机制
- 能根据需求调整参数
- 掌握最佳实践配置

**案例要求**：
- 编写简单 Prompt 测试代表性参数
- 设置 temperature = 0.7（平衡随机性和一致性）
- 设置 max_tokens = 300（控制输出长度）
- 验证点：能根据参数调节模型输出风格

### PromptTemplate
**知识点说明**：PromptTemplate 用于创建可复用的提示词模板，实现参数化填充。

**学习要求**：
- 掌握模板创建语法
- 理解变量填充机制
- 能设计灵活的模板

**案例要求**：
- 编写 PromptTemplate("写一段关于 {topic} 的介绍")
- 输入单个 topic（如 "AI"）
- 验证点：模板能动态生成 prompt 并传入 LLM

### ChatPromptTemplate
**知识点说明**：ChatPromptTemplate 是专为多轮对话设计的提示词模板体系，支持 system/user/assistant 三角色。

**学习要求**：
- 理解多角色对话结构
- 掌握角色消息格式
- 能构建复杂对话模板

**案例要求**：
- 创建 ChatPromptTemplate：
  - system：你是一个数学老师
  - user：请讲解 {concept}
- 输入 concept = "二次方程"
- 验证点：能正确填充变量并按角色生成聊天消息格式

### MessagesPlaceholder
**知识点说明**：用于在提示词模板中保留"历史消息占位"，适配 Memory 组件。

**学习要求**：
- 理解占位符作用
- 掌握动态填充机制
- 能与 Memory 组件集成

**案例要求**：
- 创建带 MessagesPlaceholder("history") 的 ChatPromptTemplate
- 手动提供 2 条历史消息进行测试
- 验证点：占位符能被历史消息正确填充

### Structured Output（结构化输出）
**知识点说明**：通过 OutputParser，让 LLM 输出 JSON 等结构化格式。

**学习要求**：
- 掌握输出解析器使用
- 理解结构化输出原理
- 能设计输出格式规范

**案例要求**：
- 要求模型输出 JSON 格式：
  - 明确 schema：{"title": "string", "summary": "string"}
- 验证点：输出满足指定 schema 并能被解析为字典

---

## 二、数据层：文档、Embedding、向量库

### Document Loaders（Text）
**知识点说明**：Loaders 用于从数据源加载文档，是 RAG 的起点。

**学习要求**：
- 掌握基础 Loader 使用
- 理解文档加载机制
- 能处理本地文档

**案例要求**：
- 使用 TextLoader 加载本地 txt 文件
- 验证返回的 Document[] 结构
- 验证点：能正常返回文档内容和元数据

### Splitters：RecursiveCharacterTextSplitter
**知识点说明**：文本切片器用于将文档按规则切分成 chunk，保证向量化质量。

**学习要求**：
- 理解文本切分原理
- 掌握切分参数设置
- 能优化切分策略

**案例要求**：
- 使用 chunk_size=500 对文档切片
- 观察切片数量和内容长度
- 验证点：文档被正确切分成指定大小的片段

### Embedding（OpenAI）
**知识点说明**：Embedding 将文本转换为向量，是向量检索的基础。

**学习要求**：
- 理解向量化原理
- 掌握 Embedding 模型使用
- 能进行文本向量化

**案例要求**：
- 对单句话进行向量化
- 检查向量维度和数据类型
- 验证点：能成功生成数值向量

### Vector Stores（FAISS）
**知识点说明**：向量库用于存储 Embedding 并进行相似度检索。

**学习要求**：
- 掌握向量库创建和使用
- 理解相似度检索原理
- 能进行向量存储和查询

**案例要求**：
- 创建 FAISS 向量库：
  - 插入 3 条预设文本向量
  - 执行相似度检索
- 验证点：能返回最相似的文本片段

### Retriever（k parameter）
**知识点说明**：Retriever 封装了向量库检索逻辑，通过参数控制检索结果。

**学习要求**：
- 理解检索器配置参数
- 掌握结果数量控制
- 能设置检索参数

**案例要求**：
- 设置 Retriever(k=2) 检索相关文档
- 验证返回结果数量
- 验证点：能正确控制检索结果数量

---

## 三、编排层：LCEL + Runnable（核心）

### Runnable
**知识点说明**：Runnable 是 LangChain 1.0 的核心抽象，所有步骤都能用 Runnable 链式拼接。

**学习要求**：
- 理解 Runnable 抽象概念
- 掌握链式拼接方法
- 能构建处理流程

**案例要求**：
- 实现 prompt → llm 的简单链
- 使用 invoke 方法调用
- 验证点：链条能顺序执行并返回结果

### RunnableMap
**知识点说明**：并行执行多个 Runnable，并将结果组合成一个字典。

**学习要求**：
- 理解并行执行机制
- 掌握结果组合方法
- 能优化处理性能

**案例要求**：
- 并行执行 LLM 调用和字符串处理：
  - LLM 生成摘要
  - 字符串计算长度
- 验证点：输出结果包含两个字段

### RunnablePassthrough
**知识点说明**：用于在链中保留原始输入，做多路分发时非常常用。

**学习要求**：
- 理解数据传递机制
- 掌握输入保留方法
- 能设计数据流路径

**案例要求**：
- 构建包含 Passthrough 的链：
  - 输入 → 复制 → LLM 处理 → 合并结果
- 验证点：原始输入值在输出中完整保留

### prompt | llm | parser（最重要写法）
**知识点说明**：LangChain 1.0 通过 "|" 操作符创建 LCEL 流水线，是推荐写法。

**学习要求**：
- 掌握管道操作符语法
- 理解数据流向
- 能构建完整处理链

**案例要求**：
- 构建完整链：
  - PromptTemplate | LLM | StrOutputParser
- 验证点：链式调用返回字符串格式结果

### OutputParser（JSON）
**知识点说明**：用于严格解析模型输出，使其强制符合结构化格式。

**学习要求**：
- 掌握解析器使用方法
- 理解格式验证机制
- 能处理解析错误

**案例要求**：
- 使用 JsonOutputParser 解析 LLM 输出
- 验证解析结果为字典格式
- 验证点：能正确解析 JSON 格式输出

### Streaming（基础）
**知识点说明**：支持流式输出，可实时查看生成过程。

**学习要求**：
- 理解流式输出原理
- 掌握流式调用方法
- 能实现基础流式功能

**案例要求**：
- 使用 stream 方法获取流式输出
- 验证返回迭代器对象
- 验证点：能逐个 token 获取输出内容

---

## 四、Memory（对话记忆）

### BufferMemory
**知识点说明**：保存完整对话记录，适合短会话。

**学习要求**：
- 理解 BufferMemory 工作原理
- 掌握对话记录管理
- 能实现基础记忆功能

**案例要求**：
- 实现 2 轮对话记忆存储
- 验证历史消息保存
- 验证点：第二轮能引用第一轮信息

### ConversationBufferMemory
**知识点说明**：更现代化的对话记忆实现，与 LCEL 兼容。

**学习要求**：
- 掌握新版 Memory 使用
- 理解与 LCEL 集成方式
- 能实现对话上下文

**案例要求**：
- 使用 ConversationBufferMemory 存储 2 条消息
- 验证消息格式和内容
- 验证点：能正确保存和检索对话历史

### 与 LCEL 组合方式
**知识点说明**：Memory 可与 LCEL 链结合，通过配置注入对话历史。

**学习要求**：
- 理解配置注入机制
- 掌握链式集成方法
- 能实现动态配置

**案例要求**：
- 将 Memory 配置注入 LCEL 链
- 验证对话历史影响
- 验证点：链式调用能包含历史上下文

---

## 五、RAG（核心能力）

### RAG Pipeline（基础）
**知识点说明**：RAG 是 LangChain 最核心能力，用检索增强生成。

**学习要求**：
- 理解 RAG 完整流程
- 掌握各组件集成
- 能构建端到端系统

**案例要求**：
- 实现最小 RAG 管线：
  - 文档加载 → 切片 → 向量化 → 检索 → 生成
- 验证点：回答基于检索到的文档内容

### 简单检索增强
**知识点说明**：基础检索增强生成，验证 RAG 核心概念。

**学习要求**：
- 掌握检索流程
- 理解上下文构建
- 能实现基础问答

**案例要求**：
- 基于 3 条文档构建问答系统
- 验证检索结果和生成答案
- 验证点：答案包含文档中的关键信息

---

## 六、行动层：Tools + Agents

### @tool 装饰器
**知识点说明**：通过 Python 函数注册成 Agent 工具。

**学习要求**：
- 掌握工具注册方法
- 理解工具调用机制
- 能设计自定义工具

**案例要求**：
- 创建一个简单的 calculator 工具
- 验证工具注册和调用
- 验证点：工具能正确执行并返回结果

### 基础 Agent 创建
**知识点说明**：创建能使用工具的基础 Agent。

**学习要求**：
- 理解 Agent 工作原理
- 掌握 Agent 创建方法
- 能实现工具调用

**案例要求**：
- 创建使用 calculator 工具的 Agent
- 验证 Agent 能调用工具解决问题
- 验证点：Agent 能自动选择并使用工具

### AgentExecutor 基础
**知识点说明**：用于执行 Agent 的主循环，管理工具调用。

**学习要求**：
- 理解执行器作用
- 掌握基础执行流程
- 能管理工具调用

**案例要求**：
- 使用 AgentExecutor 运行简单 Agent
- 验证执行过程和结果
- 验证点：AgentExecutor 能正确管理工具调用流程

---

## 七、LangGraph（高级模块）

> **注意**：LangGraph 属于高级内容，建议独立学习

### 状态（State）基础
**知识点说明**：状态用于在图执行过程中存储信息。

**学习要求**：
- 理解状态管理机制
- 掌握基础状态定义
- 能设计简单状态结构

**案例要求**：
- 定义包含 query 和 result 的简单 State
- 验证状态读写操作
- 验证点：状态能在节点间正确传递

### 节点（Node）基础
**知识点说明**：每个 Node 执行一个处理步骤。

**学习要求**：
- 理解节点执行逻辑
- 掌握节点定义方法
- 能设计处理步骤

**案例要求**：
- 创建两个简单节点：
  - 处理输入节点
  - 生成输出节点
- 验证点：节点能按顺序执行

---

## 八、应用工程能力

### FastAPI 基础部署
**知识点说明**：通过 FastAPI 将 LCEL 流水线发布为 API 服务。

**学习要求**：
- 掌握 FastAPI 基础
- 理解 API 设计
- 能部署简单服务

**案例要求**：
- 用 FastAPI 包装一个 LLM Chain
- 创建简单的 POST 端点
- 验证点：能通过 HTTP 调用并获取回复

### 基础错误处理
**知识点说明**：为 LangChain 应用添加基础的错误处理机制。

**学习要求**：
- 理解常见错误类型
- 掌握基础异常处理
- 能设计健壮的应用

**案例要求**：
- 为 LLM 调用添加 try-catch 处理
- 验证错误捕获和返回
- 验证点：异常情况下应用不会崩溃

### 简单性能优化
**知识点说明**：基础的性能优化技巧。

**学习要求**：
- 理解性能瓶颈
- 掌握基础优化方法
- 能提升响应速度

**案例要求**：
- 实现简单的响应缓存
- 验证缓存命中效果
- 验证点：重复请求能从缓存获取结果

---

## 📊 学习优先级说明

### 🟢 **核心优先级**（必须掌握）
- ChatTongyi 基础调用
- Prompt 模板系统
- LCEL 链式语法
- 基础 RAG 流程
- 简单工具和 Agent

### 🟡 **重要优先级**（建议掌握）
- 文档处理和向量检索
- Memory 对话记忆
- 基础部署和错误处理

### 🔴 **高级优先级**（可选学习）
- LangGraph 图控制
- 高级 RAG 策略
- 复杂 Agent 协作

---

## 🎯 验证原则

### **代码最小化**
- 每个案例不超过 20 行核心代码
- 避免多次 API 调用对比
- 使用预设数据减少准备时间

### **验证有效性**
- 每个验证点都有明确成功标准
- 避免需要长时间运行的测试
- 提供即时反馈机制

### **实用性导向**
- 专注 80% 常用使用场景
- 提供最佳实践配置
- 包含基础错误处理

---

## 📝 使用说明

### **生成 Notebook 时**
1. **按优先级顺序**：先核心后高级
2. **独立验证**：每个知识点独立可运行
3. **完整示例**：提供从导入到验证的完整代码
4. **错误处理**：包含基础的异常处理示例

### **学习路径建议**
1. **Week 1**：掌握核心优先级内容
2. **Week 2**：学习重要优先级内容
3. **Week 3+**：探索高级优先级内容

---

**🎯 目标**：用最少的代码，最关键的知识点，最有效的验证方式，帮助学习者快速掌握 LangChain 核心技能。
