# LangChain核心知识点练习题

## 练习题使用说明

### 难度等级说明
- **⭐ 基础练习**：掌握核心概念和基本用法（15-25分钟）
- **⭐⭐ 进阶练习**：深入理解和灵活应用（25-35分钟）
- **⭐⭐⭐ 高级练习**：复杂场景和性能优化（35-45分钟）
- **⭐⭐⭐⭐ 综合练习**：多知识点整合应用（45-60分钟）

### 时间估算说明
- 每个练习包含：理解题目(5分钟) + 编码实现(15-40分钟) + 测试验证(5-15分钟)
- 总学习时间：约80-120小时（建议分4-6周完成）
- 可根据个人基础调整学习节奏

### 先修要求说明
- 每个知识点的练习按顺序完成，确保基础扎实
- 跨知识点练习需要完成相关基础练习
- 建议每天完成2-3个练习，保持学习连续性

### 常见陷阱提醒
- **LCEL链式调用**：注意数据类型匹配，避免链中断
- **RAG系统**：切分参数不当会导致检索质量下降
- **Agent工具**：工具描述不清晰会影响Agent选择
- **消息历史**：历史过长会消耗大量token
- **向量化**：注意文本预处理，避免噪声影响

---

## 一、基础层：LLM + Prompt

### ChatModels（ChatOpenAI + GPT）

#### 练习1：基础配置验证 ⭐
**题目**：配置 ChatOpenAI 连接到 GPT 服务，实现基础对话功能
**要求**：
- 使用正确的 base_url 和 api_key 配置
- 设置 temperature=0.7, max_tokens=500
- 发送"你好，请介绍一下自己"的测试消息
**验证点**：成功获取 GPT 回复并控制输出长度
**预计时间**：20分钟
**先修要求**：无

#### 练习2：参数调优实验 ⭐⭐
**题目**：测试不同 temperature 参数对输出随机性的影响
**要求**：
- 分别设置 temperature=0.1, 0.7, 1.0
- 使用相同输入测试三次
- 对比输出结果的差异性
**验证点**：理解 temperature 参数的作用机制
**预计时间**：30分钟
**先修要求**：练习1

#### 练习3：错误处理实践 ⭐⭐
**题目**：为 ChatOpenAI 调用添加异常处理机制
**要求**：
- 捕获网络连接异常
- 捕获 API key 错误
- 捕获模型不可用异常
- 提供友好的错误提示
**验证点**：在各种异常情况下程序不崩溃
**预计时间**：25分钟
**先修要求**：练习1

#### 练习4：批量对话测试 ⭐⭐⭐
**题目**：实现批量对话处理功能
**要求**：
- 创建包含5个问题的列表
- 使用循环批量调用 ChatOpenAI
- 收集并整理所有回复
**验证点**：能高效处理多个对话请求
**预计时间**：35分钟
**先修要求**：练习2, 练习3

### 核心参数（model / temperature / max_tokens）

#### 练习1：模型性能对比
**题目**：对比不同 GPT 模型的响应速度和质量
**要求**：
- 测试 qwen-turbo 和 qwen-plus 模型
- 记录响应时间和内容质量
- 分析性能差异
**验证点**：能根据需求选择合适的模型

#### 练习2：温度参数调优
**题目**：找到最适合创意写作的 temperature 设置
**要求**：
- 测试 temperature 从 0.1 到 1.0 的梯度
- 评估创意性和连贯性平衡
- 确定最佳参数值
**验证点**：掌握参数调优方法

#### 练习3：Token 使用优化
**题目**：优化 max_tokens 设置以平衡成本和效果
**要求**：
- 测试不同长度的回复需求
- 找到最小可行的 max_tokens 值
- 验证内容完整性
**验证点**：能合理控制 token 使用

#### 练习4：参数组合实验
**题目**：设计针对不同场景的参数组合
**要求**：
- 为代码生成场景设计参数组合
- 为创意写作场景设计参数组合
- 为问答场景设计参数组合
**验证点**：能根据应用场景优化参数

### PromptTemplate

#### 练习1：单变量模板创建
**题目**：创建用于产品介绍的 PromptTemplate
**要求**：
- 设计包含 {product_name} 和 {features} 的模板
- 测试不同产品类型的输入
- 验证输出格式的一致性
**验证点**：模板能正确填充变量

#### 练习2：多变量模板设计
**题目**：创建复杂的邮件生成模板
**要求**：
- 包含收件人、发件人、主题、内容等变量
- 设计条件性内容生成
- 测试各种输入组合
**验证点**：灵活处理多变量输入

#### 练习3：模板嵌套实践
**题目**：实现模板的嵌套使用
**要求**：
- 创建基础模板和组合模板
- 实现模板的动态组合
- 验证嵌套效果
**验证点**：掌握模板复用技巧

#### 练习4：模板验证机制
**题目**：为 PromptTemplate 添加输入验证
**要求**：
- 检查必需变量是否提供
- 验证变量值的有效性
- 提供清晰的错误信息
**验证点**：确保模板使用的安全性

### ChatPromptTemplate

#### 练习1：基础角色模板
**题目**：创建包含 system、user、assistant 角色的对话模板
**要求**：
- 设置专业的 system 角色定义
- 创建带变量的 user 消息
- 测试角色切换效果
**验证点**：正确实现多角色对话

#### 练习2：动态角色切换
**题目**：实现根据场景动态切换 system 角色
**要求**：
- 创建多个 system 角色模板
- 根据输入参数选择合适角色
- 验证角色切换效果
**验证点**：灵活的角色管理机制

#### 练习3：复杂对话流程
**题目**：设计多轮对话的完整流程
**要求**：
- 包含开场、深入了解、总结三个阶段
- 每个阶段使用不同的角色设定
- 实现阶段间的平滑过渡
**验证点**：构建完整的对话体验

#### 练习4：角色模板优化
**题目**：优化 ChatPromptTemplate 的性能和效果
**要求**：
- 减少不必要的 token 消耗
- 提高角色指令的准确性
- 测试不同优化策略
**验证点**：提升模板的实用效率

### MessagesPlaceholder

#### 练习1：基础历史消息处理
**题目**：使用 MessagesPlaceholder 处理对话历史
**要求**：
- 创建带历史占位符的模板
- 手动构造历史消息列表
- 验证历史消息的正确插入
**验证点**：占位符能正确填充历史消息

#### 练习2：动态历史管理
**题目**：实现动态添加和管理历史消息
**要求**：
- 创建历史消息管理器
- 实现消息的添加、删除、查询
- 与 MessagesPlaceholder 集成
**验证点**：灵活的历史消息操作

#### 练习3：历史长度控制
**题目**：控制历史消息的长度以优化性能
**要求**：
- 实现历史消息的截断策略
- 保留重要的上下文信息
- 测试不同长度限制的效果
**验证点**：平衡上下文和性能

#### 练习4：多会话历史隔离
**题目**：实现多个会话的历史消息隔离
**要求**：
- 为不同会话创建独立历史
- 防止历史消息混淆
- 测试会话切换效果
**验证点**：确保会话间的独立性

### Structured Output（OpenAI接口推荐方式）

#### 练习1：基础 Pydantic 模型定义
**题目**：定义文章分析的结构化输出模型
**要求**：
- 创建包含标题、摘要、关键词的 Pydantic 模型
- 使用 with_structured_output() 方法
- 验证输出格式的正确性
**验证点**：GPT 输出符合指定结构

#### 练习2：复杂嵌套结构
**题目**：设计包含嵌套关系的复杂输出结构
**要求**：
- 定义多层嵌套的 Pydantic 模型
- 处理可选字段和列表字段
- 验证嵌套结构的完整性
**验证点**：正确处理复杂的数据结构

#### 练习3：多模型输出
**题目**：根据输入动态选择不同的输出模型
**要求**：
- 定义多个 Pydantic 模型
- 实现模型选择逻辑
- 测试不同场景的输出
**验证点**：灵活的输出格式切换

#### 练习4：输出验证和错误处理
**题目**：为结构化输出添加验证和错误处理
**要求**：
- 验证输出字段的合法性
- 处理模型输出失败的情况
- 提供降级处理方案
**验证点**：确保结构化输出的稳定性

---

## 二、数据层：文档、Embedding、向量库

### Document Loaders（Text）

#### 练习1：基础文本加载
**题目**：使用 TextLoader 加载本地中文文档
**要求**：
- 创建测试用的中文 txt 文件
- 使用 TextLoader 加载文档
- 检查 Document 对象的结构
**验证点**：正确加载中文文档内容和元数据

#### 练习2：批量文档处理
**题目**：实现批量加载多个文本文件
**要求**：
- 创建多个测试文档
- 使用循环批量加载
- 整合所有文档内容
**验证点**：高效处理多个文档

#### 练习3：编码问题处理
**题目**：处理不同编码格式的文本文件
**要求**：
- 测试 UTF-8、GBK 等编码格式
- 实现编码自动检测
- 处理编码转换错误
**验证点**：正确处理各种编码格式

#### 练习4：文档元数据扩展
**题目**：为加载的文档添加自定义元数据
**要求**：
- 在加载过程中添加文件路径、大小等信息
- 实现元数据的自动提取
- 验证元数据的完整性
**验证点**：丰富文档的元数据信息

### Splitters：RecursiveCharacterTextSplitter

#### 练习1：基础文本切分
**题目**：使用 RecursiveCharacterTextSplitter 切分中文文档
**要求**：
- 设置 chunk_size=500, chunk_overlap=50
- 切分长篇中文文档
- 分析切分结果
**验证点**：文档被正确切分成指定大小

#### 练习2：切分参数优化
**题目**：找到最佳的切分参数组合
**要求**：
- 测试不同的 chunk_size 和 chunk_overlap
- 评估切分效果对检索质量的影响
- 确定最优参数
**验证点**：掌握切分参数的调优方法

#### 练习3：智能切分策略
**题目**：实现基于段落和句子的智能切分
**要求**：
- 保持段落完整性
- 避免在句子中间切分
- 测试切分质量
**验证点**：提高切分的语义完整性

#### 练习4：切分效果评估
**题目**：建立切分效果的评估机制
**要求**：
- 设计切分质量指标
- 实现自动化评估
- 对比不同切分策略
**验证点**：量化切分效果

### Embedding（GPT DashScope）

#### 练习1：基础文本向量化
**题目**：使用 DashScope Embeddings 向量化中文文本
**要求**：
- 向量化单句中文文本
- 检查向量维度和数据类型
- 验证向量的数值范围
**验证点**：成功生成数值向量

#### 练习2：批量向量化
**题目**：实现批量文本的高效向量化
**要求**：
- 向量化多个文本片段
- 优化批处理大小
- 监控处理速度
**验证点**：提升向量化处理效率

#### 练习3：向量相似度计算
**题目**：计算文本向量间的相似度
**要求**：
- 向量化多个相关文本
- 计算余弦相似度
- 验证相似度的合理性
**验证点**：正确评估文本相关性

#### 练习4：向量化性能优化
**题目**：优化向量化过程的性能和成本
**要求**：
- 实现向量缓存机制
- 优化 API 调用频率
- 监控 token 使用量
**验证点**：降低向量化成本

### Vector Stores（FAISS + GPT）

#### 练习1：基础向量库创建
**题目**：使用 FAISS 创建基础向量库
**要求**：
- 插入 3-5 条中文文本向量
- 创建 FAISS 索引
- 验证向量存储
**验证点**：成功创建和填充向量库

#### 练习2：相似度检索
**题目**：实现基于向量的相似度检索
**要求**：
- 构建包含多个文档的向量库
- 执行相似度查询
- 返回最相似的文档
**验证点**：准确检索相似内容

#### 练习3：批量检索优化
**题目**：优化批量检索的性能
**要求**：
- 实现批量查询处理
- 优化检索算法参数
- 提升检索速度
**验证点**：高效处理多个查询

#### 练习4：向量库持久化
**题目**：实现向量库的保存和加载
**要求**：
- 将 FAISS 索引保存到文件
- 从文件恢复向量库
- 验证数据完整性
**验证点**：实现向量库的持久化存储

### Retriever（k parameter）

#### 练习1：基础检索器配置
**题目**：配置 Retriever 的 k 参数控制检索数量
**要求**：
- 设置不同的 k 值（1, 3, 5）
- 对比检索结果数量
- 分析结果质量差异
**验证点**：正确控制检索结果数量

#### 练习2：检索策略优化
**题目**：优化检索策略以提高相关性
**要求**：
- 调整相似度阈值
- 实现结果过滤机制
- 测试不同策略效果
**验证点**：提升检索结果的相关性

#### 练习3：多路检索合并
**题目**：实现多个检索器的结果合并
**要求**：
- 创建多个不同参数的检索器
- 合并检索结果
- 去重和排序
**验证点**：综合多个检索策略

#### 练习4：检索性能监控
**题目**：监控和优化检索性能
**要求**：
- 记录检索时间和准确率
- 识别性能瓶颈
- 实施优化措施
**验证点**：提升检索系统性能

---

## 三、编排层：LCEL + Runnable（核心）

### Runnable

#### 练习1：基础链式调用
**题目**：构建 prompt → llm 的简单链
**要求**：
- 创建 PromptTemplate
- 连接 ChatOpenAI
- 使用 invoke 方法调用
**验证点**：链条能顺序执行并返回结果

#### 练习2：多步骤处理链
**题目**：构建包含多个处理步骤的复杂链
**要求**：
- 添加文本预处理步骤
- 包含后处理步骤
- 验证数据流转
**验证点**：实现完整的数据处理流程

#### 练习3：链式错误处理
**题目**：为 Runnable 链添加错误处理机制
**要求**：
- 捕获链中任意步骤的异常
- 实现错误恢复策略
- 提供调试信息
**验证点**：增强链的健壮性

#### 练习4：动态链构建
**题目**：根据输入动态构建处理链
**要求**：
- 根据参数选择处理步骤
- 实现链的动态组合
- 测试不同场景
**验证点**：灵活的链构建能力

### RunnableMap

#### 练习1：并行执行基础
**题目**：使用 RunnableMap 并行执行多个任务
**要求**：
- 并行执行 LLM 调用和字符串处理
- 收集并行结果
- 验证执行效率
**验证点**：正确并行执行并组合结果

#### 练习2：复杂并行流程
**题目**：设计复杂的多路并行处理流程
**要求**：
- 包含多个并行分支
- 实现结果依赖关系
- 优化并行性能
**验证点**：高效的多任务并行处理

#### 练习3：条件并行执行
**题目**：实现基于条件的并行任务选择
**要求**：
- 根据输入选择并行任务
- 动态调整并行策略
- 测试各种条件
**验证点**：智能的并行任务管理

#### 练习4：并行结果聚合
**题目**：实现复杂的并行结果聚合逻辑
**要求**：
- 设计多种聚合策略
- 处理部分失败的情况
- 优化聚合性能
**验证点**：灵活的结果聚合机制

### RunnablePassthrough

#### 练习1：基础数据传递
**题目**：使用 RunnablePassthrough 保留原始输入
**要求**：
- 构建包含 Passthrough 的链
- 验证输入数据的完整性
- 测试多路分发
**验证点**：原始输入在输出中完整保留

#### 练习2：复杂数据流设计
**题目**：设计复杂的数据流转路径
**要求**：
- 实现数据的多路分发
- 保持数据的一致性
- 优化数据流效率
**验证点**：高效的数据流管理

#### 练习3：条件数据传递
**题目**：实现基于条件的数据传递策略
**要求**：
- 根据数据特征选择传递路径
- 实现动态数据路由
- 测试各种场景
**验证点**：智能的数据路由机制

#### 练习4：数据变换和传递
**题目**：结合数据变换和传递功能
**要求**：
- 在传递过程中进行数据变换
- 保持原始数据的备份
- 验证变换的正确性
**验证点**：灵活的数据处理能力

### prompt | llm | parser（GPT最重要写法）

#### 练习1：基础管道构建
**题目**：使用 "|" 操作符构建基础处理管道
**要求**：
- 构建 PromptTemplate | LLM | StrOutputParser 链
- 测试管道的执行
- 验证输出格式
**验证点**：链式调用返回正确格式结果

#### 练习2：复杂管道组合
**题目**：构建包含多个处理步骤的复杂管道
**要求**：
- 添加数据预处理步骤
- 包含多个解析器
- 实现条件分支
**验证点**：构建完整的处理流水线

#### 练习3：管道性能优化
**题目**：优化管道的执行性能
**要求**：
- 减少不必要的数据传递
- 优化步骤间的接口
- 监控执行时间
**验证点**：提升管道执行效率

#### 练习4：动态管道配置
**题目**：实现管道的动态配置和切换
**要求**：
- 根据参数选择不同的组件
- 实现运行时管道重构
- 测试配置切换
**验证点**：灵活的管道配置能力

### OutputParser（传统方式，兼容性）

#### 练习1：JSON 解析基础
**题目**：使用 JsonOutputParser 解析 LLM 输出
**要求**：
- 生成 JSON 格式的输出
- 使用 JsonOutputParser 解析
- 验证解析结果
**验证点**：正确解析 JSON 格式输出

#### 练习2：自定义解析器
**题目**：创建自定义的输出解析器
**要求**：
- 继承 BaseOutputParser
- 实现特定的解析逻辑
- 处理解析错误
**验证点**：实现定制化的输出解析

#### 练习3：解析器链组合
**题目**：组合多个解析器处理复杂输出
**要求**：
- 设计多阶段解析流程
- 实现解析器的串联
- 处理中间结果
**验证点**：处理复杂的解析需求

#### 练习4：解析错误处理
**题目**：为输出解析添加完善的错误处理
**要求**：
- 捕获各种解析异常
- 实现错误恢复机制
- 提供详细的错误信息
**验证点**：增强解析的健壮性

### Streaming（GPT流式输出）

#### 练习1：基础流式输出
**题目**：使用 stream 方法获取流式输出
**要求**：
- 实现基础的流式调用
- 逐个 token 处理输出
- 验证流式效果
**验证点**：能逐个 token 获取输出内容

#### 练习2：流式输出处理
**题目**：实现流式输出的实时处理
**要求**：
- 实时显示生成内容
- 实现输出缓冲机制
- 处理流式中断
**验证点**：流畅的流式输出体验

#### 练习3：流式性能优化
**题目**：优化流式输出的性能表现
**要求**：
- 减少流式延迟
- 优化缓冲策略
- 监控资源使用
**验证点**：提升流式输出效率

#### 练习4：多路流式输出
**题目**：实现多个流的并发处理
**要求**：
- 并发处理多个流式输出
- 实现流的结果合并
- 管理流的生命周期
**验证点**：高效的多流处理能力

---

## 四、消息历史管理（GPT + LangChain 1.0+）

### ChatMessageHistory 基础

#### 练习1：基础历史记录
**题目**：创建和管理基础的消息历史
**要求**：
- 创建 ChatMessageHistory 实例
- 添加用户和助手消息
- 验证消息格式
**验证点**：正确保存和检索对话历史

#### 练习2：历史消息操作
**题目**：实现历史消息的增删改查
**要求**：
- 实现消息的添加、删除、修改
- 实现消息的查询功能
- 验证操作的正确性
**验证点**：完整的历史消息管理

#### 练习3：历史持久化
**题目**：实现消息历史的持久化存储
**要求**：
- 将历史保存到文件
- 从文件恢复历史
- 验证数据完整性
**验证点**：实现历史的持久化

#### 练习4：历史清理策略
**题目**：实现智能的历史消息清理
**要求**：
- 设计清理策略（时间、数量等）
- 保留重要消息
- 实现自动清理
**验证点**：合理控制历史大小

### RunnableWithMessageHistory

#### 练习1：基础历史链包装
**题目**：使用 RunnableWithMessageHistory 包装基础链
**要求**：
- 创建基础 LCEL 链
- 使用历史包装器
- 配置会话参数
**验证点**：多轮对话能保持历史上下文

#### 练习2：会话管理
**题目**：实现多会话的历史管理
**要求**：
- 配置 session_id 机制
- 实现会话隔离
- 测试会话切换
**验证点**：不同会话的历史互不干扰

#### 练习3：历史工厂模式
**题目**：实现历史对象工厂模式
**要求**：
- 创建 history_factory
- 实现动态历史创建
- 优化资源使用
**验证点**：高效的历史对象管理

#### 练习4：历史链优化
**题目**：优化历史链的性能和效果
**要求**：
- 减少历史传递的开销
- 优化历史格式
- 提升响应速度
**验证点**：提升历史链的实用性

### 消息历史配置模式

#### 练习1：动态配置注入
**题目**：实现消息历史的动态配置
**要求**：
- 设计配置参数结构
- 实现运行时配置更新
- 测试配置效果
**验证点**：灵活的历史配置管理

#### 练习2：配置模板系统
**题目**：创建可复用的配置模板
**要求**：
- 设计配置模板结构
- 实现模板的继承和覆盖
- 测试模板应用
**验证点**：高效的配置复用机制

#### 练习3：配置验证机制
**题目**：为历史配置添加验证机制
**要求**：
- 验证配置参数的合法性
- 检查配置的一致性
- 提供错误提示
**验证点**：确保配置的正确性

#### 练习4：配置性能优化
**题目**：优化配置系统的性能
**要求**：
- 实现配置缓存
- 减少配置加载时间
- 优化配置更新
**验证点**：提升配置系统效率

---

## 五、RAG（GPT核心能力）

### RAG Pipeline（基础）

#### 练习1：最小 RAG 实现
**题目**：实现基础的 RAG 处理管线
**要求**：
- 文档加载 → 切片 → 向量化 → 检索 → 生成
- 使用中文文档测试
- 验证各环节正确性
**验证点**：GPT 回答基于检索到的文档内容

#### 练习2：RAG 组件优化
**题目**：优化 RAG 各个组件的性能
**要求**：
- 优化文档切分策略
- 改进向量化质量
- 提升检索准确性
**验证点**：提升整体 RAG 效果

#### 练习3：多文档 RAG
**题目**：实现多文档的 RAG 处理
**要求**：
- 处理多个不同主题的文档
- 实现跨文档检索
- 验证回答的综合性
**验证点**：综合多个文档信息生成回答

#### 练习4：RAG 性能监控
**题目**：建立 RAG 系统的性能监控
**要求**：
- 监控各环节处理时间
- 跟踪检索准确率
- 识别性能瓶颈
**验证点**：量化 RAG 系统性能

### 简单检索增强

#### 练习1：基础问答系统
**题目**：基于少量文档构建问答系统
**要求**：
- 使用 3-5 条中文文档
- 实现检索增强问答
- 验证答案质量
**验证点**：答案包含文档中的关键信息

#### 练习2：检索策略对比
**题目**：对比不同检索策略的效果
**要求**：
- 测试相似度检索、关键词检索等
- 对比检索质量和速度
- 选择最优策略
**验证点**：掌握检索策略选择方法

#### 练习3：上下文优化
**题目**：优化检索到的上下文信息
**要求**：
- 改进上下文长度控制
- 优化上下文相关性
- 提升生成质量
**验证点**：提高上下文利用效率

#### 练习4：检索结果评估
**题目**：建立检索结果的评估机制
**要求**：
- 设计评估指标
- 实现自动化评估
- 持续优化效果
**验证点**：量化检索质量

---

## 六、行动层：Tools + Agents（GPT）

### @tool 装饰器

#### 练习1：基础工具创建
**题目**：使用 @tool 装饰器创建简单工具
**要求**：
- 创建计算器工具
- 添加文档字符串
- 测试工具调用
**验证点**：工具能正确执行并返回结果

#### 练习2：复杂工具设计
**题目**：创建功能复杂的自定义工具
**要求**：
- 实现文件操作工具
- 添加参数验证
- 处理异常情况
**验证点**：实现实用的工具功能

#### 练习3：工具链组合
**题目**：实现多个工具的链式调用
**要求**：
- 创建相关联的工具集
- 实现工具间的数据传递
- 测试工具链效果
**验证点**：工具能协同工作

#### 练习4：工具性能优化
**题目**：优化工具的执行性能
**要求**：
- 减少工具调用开销
- 实现结果缓存
- 监控执行时间
**验证点**：提升工具执行效率

### Agent 创建（GPT + LangChain 1.0+ 完整流程）

#### 练习1：基础 Agent 创建
**题目**：使用 create_react_agent 创建基础 Agent
**要求**：
- 配置 LLM、工具、提示词
- 创建 Agent 实例
- 测试基本功能
**验证点**：Agent 能调用工具解决问题

#### 练习2：Agent 提示词优化
**题目**：优化 Agent 的提示词设计
**要求**：
- 设计清晰的工具使用说明
- 优化推理流程引导
- 测试不同提示词效果
**验证点**：提升 Agent 的决策能力

#### 练习3：多工具 Agent
**题目**：创建使用多个工具的复杂 Agent
**要求**：
- 集成多种类型工具
- 实现工具选择逻辑
- 测试复杂任务处理
**验证点**：Agent 能智能选择合适工具

#### 练习4：Agent 错误处理
**题目**：为 Agent 添加完善的错误处理
**要求**：
- 处理工具调用失败
- 实现错误恢复策略
- 提供调试信息
**验证点**：增强 Agent 的健壮性

### AgentExecutor 基础

#### 练习1：基础执行器配置
**题目**：配置和使用 AgentExecutor
**要求**：
- 创建 AgentExecutor 实例
- 配置执行参数
- 测试执行流程
**验证点**：执行器能正确管理工具调用

#### 练习2：执行器监控
**题目**：监控 AgentExecutor 的执行过程
**要求**：
- 记录执行步骤
- 监控工具调用
- 分析执行效率
**验证点**：了解 Agent 的执行细节

#### 练习3：执行器优化
**题目**：优化 AgentExecutor 的性能
**要求**：
- 减少不必要的工具调用
- 优化执行流程
- 提升响应速度
**验证点**：提升执行器效率

#### 练习4：高级执行策略
**题目**：实现高级的执行策略
**要求**：
- 实现并行工具调用
- 添加执行超时控制
- 实现智能重试机制
**验证点**：增强执行器的功能性

---

## 七、LangGraph（高级模块）

### 状态（State）基础

#### 练习1：基础状态定义
**题目**：定义和使用基础的图状态
**要求**：
- 定义包含 query 和 result 的 State
- 实现状态的读写操作
- 验证状态传递
**验证点**：状态能在节点间正确传递

#### 练习2：复杂状态结构
**题目**：设计复杂的状态数据结构
**要求**：
- 包含嵌套数据类型
- 实现状态验证
- 测试状态操作
**验证点**：正确处理复杂状态数据

#### 练习3：状态持久化
**题目**：实现图状态的持久化存储
**要求**：
- 保存状态到文件
- 从文件恢复状态
- 验证数据完整性
**验证点**：实现状态的持久化

#### 练习4：状态版本管理
**题目**：实现状态的版本控制机制
**要求**：
- 跟踪状态变更历史
- 实现状态回滚
- 管理状态版本
**验证点**：灵活的状态版本管理

### 节点（Node）基础

#### 练习1：基础节点创建
**题目**：创建基础的图节点
**要求**：
- 实现输入处理节点
- 实现输出生成节点
- 测试节点执行
**验证点**：节点能按顺序正确执行

#### 练习2：节点间通信
**题目**：实现节点间的数据通信
**要求**：
- 设计节点接口
- 实现数据传递
- 验证通信正确性
**验证点**：节点能有效交换数据

#### 练习3：条件节点执行
**题目**：实现基于条件的节点执行
**要求**：
- 设计条件判断逻辑
- 实现动态节点选择
- 测试各种条件
**验证点**：智能的节点执行控制

#### 练习4：节点性能优化
**题目**：优化节点的执行性能
**要求**：
- 减少节点处理时间
- 优化数据传递
- 并行化节点执行
**验证点**：提升图的整体性能

---

## 八、应用工程能力（GPT）

### FastAPI 基础部署

#### 练习1：基础 API 服务
**题目**：使用 FastAPI 部署 LLM Chain
**要求**：
- 创建 FastAPI 应用
- 包装 LLM Chain 为 API
- 测试 API 调用
**验证点**：能通过 HTTP 调用获取 GPT 回复

#### 练习2：API 参数验证
**题目**：为 API 添加参数验证和错误处理
**要求**：
- 验证输入参数格式
- 处理 API 异常
- 返回标准化错误
**验证点**：提供稳定可靠的 API 服务

#### 练习3：API 性能优化
**题目**：优化 API 的性能表现
**要求**：
- 实现响应缓存
- 优化并发处理
- 监控 API 性能
**验证点**：提升 API 响应速度

#### 练习4：API 文档和测试
**题目**：完善 API 的文档和测试
**要求**：
- 生成 API 文档
- 编写单元测试
- 实现集成测试
**验证点**：提供完整的 API 文档和测试

### LCEL 配置管理

#### 练习1：动态配置切换
**题目**：实现 LCEL 链的动态配置
**要求**：
- 配置多个模型选项
- 实现运行时切换
- 测试配置效果
**验证点**：能动态切换不同的模型配置

#### 练习2：配置模板系统
**题目**：创建可复用的配置模板
**要求**：
- 设计配置模板结构
- 实现模板继承
- 测试模板应用
**验证点**：高效的配置复用机制

#### 练习3：配置验证机制
**题目**：为配置添加验证和错误处理
**要求**：
- 验证配置参数
- 处理配置错误
- 提供错误提示
**验证点**：确保配置的正确性

#### 练习4：配置热更新
**题目**：实现配置的热更新机制
**要求**：
- 监听配置变更
- 实现无缝切换
- 测试更新效果
**验证点**：无需重启即可更新配置

### 基础错误处理

#### 练习1：异常捕获机制
**题目**：为 LLM 调用添加异常处理
**要求**：
- 捕获网络异常
- 处理 API 错误
- 提供友好提示
**验证点**：异常情况下应用不崩溃

#### 练习2：错误恢复策略
**题目**：实现智能的错误恢复机制
**要求**：
- 实现自动重试
- 设计降级策略
- 记录错误日志
**验证点**：增强系统的容错能力

#### 练习3：错误监控系统
**题目**：建立错误监控和报警机制
**要求**：
- 监控错误率
- 实现报警通知
- 分析错误趋势
**验证点**：及时发现和处理问题

#### 练习4：用户友好错误
**题目**：提供用户友好的错误提示
**要求**：
- 设计清晰的错误消息
- 提供解决建议
- 实现多语言支持
**验证点**：提升用户体验

### 简单性能优化

#### 练习1：响应缓存实现
**题目**：实现 LLM 响应的缓存机制
**要求**：
- 设计缓存策略
- 实现缓存存储
- 测试缓存效果
**验证点**：重复请求能从缓存获取结果

#### 练习2：并发处理优化
**题目**：优化并发处理能力
**要求**：
- 实现请求池化
- 优化资源使用
- 监控并发性能
**验证点**：提升系统并发处理能力

#### 练习3：资源使用优化
**题目**：优化系统资源使用
**要求**：
- 监控内存和 CPU 使用
- 优化资源分配
- 减少资源浪费
**验证点**：提高资源利用效率

#### 练习4：性能监控体系
**题目**：建立完整的性能监控体系
**要求**：
- 监控关键指标
- 实现性能分析
- 建立报警机制
**验证点**：全面掌握系统性能状况

---

## 练习题使用说明

### 难度等级说明
- **基础练习**：掌握核心概念和基本用法
- **进阶练习**：深入理解和灵活应用
- **高级练习**：复杂场景和性能优化
- **综合练习**：多知识点整合应用

### 学习路径建议
1. **基础层**：按顺序完成，为后续学习打基础
2. **数据层**：重点掌握文档处理和向量化
3. **编排层**：核心技能，需要大量练习
4. **应用层**：根据实际需求选择性学习

### 实践建议
- 每个知识点至少完成基础练习
- 重点知识点建议完成所有练习
- 遇到问题时参考验证点进行调试
- 建议记录练习过程中的问题和解决方案

### 评估标准
- **功能正确性**：代码能正确运行并得到预期结果
- **代码质量**：代码结构清晰，符合最佳实践
- **性能表现**：在合理的时间和资源消耗内完成任务
- **错误处理**：能妥善处理各种异常情况
- **扩展性**：代码具有良好的扩展和维护性
